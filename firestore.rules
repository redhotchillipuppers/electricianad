rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions for validation
    function isAuthenticated() {
      return request.auth != null;
    }

    function isAdmin() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role in ['admin', 'superadmin'];
    }

    function isProvider() {
      return isAuthenticated() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'provider';
    }

    function isAssignedProvider(quoteData) {
      return isProvider() &&
             exists(/databases/$(database)/documents/users/$(request.auth.uid)) &&
             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.providerId == quoteData.assignedProviderId;
    }

    function isValidEmail(email) {
      return email.matches('^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$');
    }

    function isValidPhone(phone) {
      return phone.matches('^[0-9\\s\\-\\+\\(\\)]+$');
    }

    function getProviderIdForUser() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.providerId;
    }

    // Quote requests collection
    match /quotes/{quoteId} {
      // Anyone can create a quote (public submission)
      // Updated to match actual data structure from submitQuote.ts
      allow create: if request.resource.data.keys().hasAll(['name', 'email', 'contactMethod', 'description', 'houseFlatNumber', 'streetName', 'postcode', 'createdAt', 'assignedProviderId'])
                    && isValidEmail(request.resource.data.email)
                    && request.resource.data.name is string && request.resource.data.name.size() > 0
                    && request.resource.data.contactMethod is string && request.resource.data.contactMethod.size() > 0
                    && request.resource.data.description is string
                    && request.resource.data.houseFlatNumber is string
                    && request.resource.data.streetName is string
                    && request.resource.data.postcode is string
                    && request.resource.data.createdAt is string
                    && request.resource.data.assignedProviderId == null
                    && (!request.resource.data.keys().hasAny(['phone']) || request.resource.data.phone is string)
                    && (!request.resource.data.keys().hasAny(['fileUrl']) || request.resource.data.fileUrl is string);

      // Admins can read/update/delete all quotes
      // Providers can only read quotes assigned to them
      allow read: if isAdmin() || isAssignedProvider(resource.data);

      // Allow updates from:
      // 1. Admins (full access)
      // 2. Assigned providers (limited to status and notes fields only)
      allow update: if isAdmin() || (
                      isAssignedProvider(resource.data)
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'completionStatus', 'notes', 'completedAt', 'completedBy', 'providerNotes'])
                    );

      // Only admins can delete quotes
      allow delete: if isAdmin();
    }

    // Service providers collection
    match /serviceProviders/{providerId} {
      // Anyone can create a provider application (public submission)
      // Updated to match actual data structure from submitServiceProvider.ts
      allow create: if request.resource.data.keys().hasAll(['firstName', 'lastName', 'email', 'primaryContactNumber', 'serviceAreas', 'status', 'createdAt'])
                    && isValidEmail(request.resource.data.email)
                    && isValidPhone(request.resource.data.primaryContactNumber)
                    && request.resource.data.firstName is string && request.resource.data.firstName.size() > 0
                    && request.resource.data.lastName is string && request.resource.data.lastName.size() > 0
                    && request.resource.data.primaryContactNumber is string && request.resource.data.primaryContactNumber.size() > 0
                    && request.resource.data.serviceAreas is list && request.resource.data.serviceAreas.size() > 0
                    && request.resource.data.status == 'pending'
                    && request.resource.data.createdAt is string
                    && (!request.resource.data.keys().hasAny(['companyName']) || request.resource.data.companyName is string);

      // Multi-tier read access:
      // - Admins can see everything
      // - Providers can see their own record
      // - Public can only see approved providers (business directory model)
      allow read: if isAdmin() ||
                  (isProvider() && providerId == getProviderIdForUser()) ||
                  resource.data.status == 'approved';

      // Allow updates from:
      // 1. Admins (full access)
      // 2. Authenticated providers updating their own document to mark account as created
      allow update: if isAdmin() || (
                      isAuthenticated()
                      && resource.data.email == request.auth.token.email
                      && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['accountCreated', 'userId', 'accountCreatedAt'])
                      && request.resource.data.accountCreated == true
                      && request.resource.data.userId == request.auth.uid
                    );

      // Only admins can delete provider applications
      allow delete: if isAdmin();
    }

    // Users collection (admin and provider accounts)
    match /users/{userId} {
      // Users can only read their own document
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // Allow user creation for:
      // 1. Admins creating admin/superadmin accounts
      // 2. Authenticated users creating their own provider account
      allow create: if (
                      // Admins can create admin/superadmin users
                      isAdmin()
                      && request.resource.data.keys().hasAll(['email', 'role', 'createdAt'])
                      && isValidEmail(request.resource.data.email)
                      && request.resource.data.role in ['admin', 'superadmin']
                      && request.resource.data.createdAt is timestamp
                    ) || (
                      // Authenticated users can create their own provider account
                      isAuthenticated()
                      && request.auth.uid == userId
                      && request.resource.data.uid == request.auth.uid
                      && request.resource.data.role == 'provider'
                      && isValidEmail(request.resource.data.email)
                      && request.resource.data.email == request.auth.token.email
                      && request.resource.data.status in ['active', 'inactive']
                      && request.resource.data.providerId is string
                      && request.resource.data.firstName is string
                      && request.resource.data.lastName is string
                      && request.resource.data.createdAt is string
                      && (!request.resource.data.keys().hasAny(['companyName']) || request.resource.data.companyName is string)
                    );

      // Users cannot update or delete their own document
      // Only superadmins can update/delete user documents
      allow update, delete: if isAdmin() &&
                             get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin';
    }

    // Deny access to all other documents
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
